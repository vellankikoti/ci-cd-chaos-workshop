pipeline {
    agent any

    environment {
        // Use dynamic workspace path instead of hardcoded
        SCENARIO_PATH = "${WORKSPACE}/Jenkins/jenkins_scenarios/scenario_01_docker_build"
        IMAGE_NAME = "chaos-workshop-docker-build"
        BUILD_TAG = "${BUILD_NUMBER}"
        CONTAINER_NAME = "chaos-app-v${params.APP_VERSION}"
        IMAGE_TAG = "ci-cd-chaos-app:v${params.APP_VERSION}"
        DOCKERFILE_PATH = "${SCENARIO_PATH}/Dockerfile"
    }

    parameters {
        string(
            name: 'APP_VERSION',
            defaultValue: '1',
            description: 'Which app version (1-5) do you want to build and run?'
        )
        booleanParam(
            name: 'CLEANUP_AFTER',
            defaultValue: false,
            description: 'Remove the app container after pipeline? (Default: false, so you can demo and inspect)'
        )
    }

    stages {
        stage('üîß Setup Docker Permissions') {
            steps {
                sh '''
                    echo "üîß Setting up Docker permissions..."
                    
                    # Ensure Docker socket is accessible
                    if [ ! -S /var/run/docker.sock ]; then
                        echo "ERROR: Docker socket not found at /var/run/docker.sock!"
                        echo "Make sure Docker is running and the socket is mounted in Jenkins container"
                        exit 1
                    fi
                    
                    # Check current user and Docker socket permissions
                    echo "Current user: $(whoami)"
                    echo "Docker socket permissions: $(ls -la /var/run/docker.sock)"
                    
                    # Try to fix permissions if needed (ignore errors if no sudo access)
                    sudo chmod 666 /var/run/docker.sock 2>/dev/null || echo "Note: Could not change socket permissions (no sudo access)"
                    
                    # Test Docker access
                    if docker ps > /dev/null 2>&1; then
                        echo "‚úÖ Docker access verified successfully"
                        docker --version
                    else
                        echo "‚ùå ERROR: Cannot access Docker daemon"
                        echo "Please ensure:"
                        echo "1. Docker is running"
                        echo "2. Jenkins container has Docker socket mounted: -v /var/run/docker.sock:/var/run/docker.sock"
                        echo "3. Jenkins user has Docker permissions"
                        exit 1
                    fi
                '''
            }
        }

        stage('üìÅ Verify Local Workspace') {
            steps {
                sh '''
                    echo "=== WORKSPACE VERIFICATION ==="
                    echo "Current working directory: $(pwd)"
                    echo "WORKSPACE environment variable: ${WORKSPACE}"
                    echo "SCENARIO_PATH: ${SCENARIO_PATH}"
                    
                    echo "=== Workspace contents ==="
                    ls -la
                    
                    echo "=== Checking for Jenkins directory ==="
                    if [ -d "Jenkins" ]; then
                        echo "‚úÖ Jenkins directory found"
                        ls -la Jenkins/
                    else
                        echo "‚ùå Jenkins directory not found in workspace"
                        echo "Available directories:"
                        ls -la
                        exit 1
                    fi
                    
                    echo "=== Checking scenario directory ==="
                    if [ -d "${SCENARIO_PATH}" ]; then
                        echo "‚úÖ Scenario directory found: ${SCENARIO_PATH}"
                        ls -la "${SCENARIO_PATH}/"
                    else
                        echo "‚ùå Scenario directory not found: ${SCENARIO_PATH}"
                        echo "Checking if Jenkins scenarios exist..."
                        find . -name "scenario_01_docker_build" -type d
                        exit 1
                    fi

                    echo "=== Checking required files ==="
                    for file in Dockerfile requirements.txt; do
                        if [ -f "${SCENARIO_PATH}/${file}" ]; then
                            echo "‚úÖ ${file} found"
                        else
                            echo "‚ùå ${file} not found in ${SCENARIO_PATH}"
                            echo "Contents of scenario directory:"
                            ls -la "${SCENARIO_PATH}/"
                            exit 1
                        fi
                    done
                    
                    echo "=== Checking app directory ==="
                    if [ -d "${SCENARIO_PATH}/app" ]; then
                        echo "‚úÖ App directory found"
                        ls -la "${SCENARIO_PATH}/app/"
                    else
                        echo "‚ùå App directory not found"
                        exit 1
                    fi
                    
                    echo "‚úÖ All workspace verification checks passed!"
                '''
            }
        }

        stage('Validate Version') {
            steps {
                script {
                    def allowedVersions = ['1','2','3','4','5']
                    if (!allowedVersions.contains(params.APP_VERSION)) {
                        echo '''
üö´ CHAOS AGENT STRIKES AGAIN! üö´
Invalid version!

Valid versions are: 1, 2, 3, 4, 5.
'''
                        error("Invalid APP_VERSION: ${params.APP_VERSION}")
                    } else {
                        echo "‚úÖ Version ${params.APP_VERSION} selected. Proceeding..."
                    }
                }
            }
        }

        stage('üßπ Pre-Cleanup') {
            steps {
                sh '''
                    echo "üî™ Pre-cleanup: Killing any leftover app containers..."
                    docker ps -q --filter publish=3000 | xargs -r docker rm -f || true
                    docker ps -a --filter "name=$CONTAINER_NAME" -q | xargs -r docker rm -f || true
                '''
            }
        }

        stage('üîß Build Docker Image') {
            steps {
                sh """
                    APP_VERSION=${params.APP_VERSION}
                    echo "üê≥ Building Docker image for version \$APP_VERSION..."
                    echo "Current directory: \$(pwd)"
                    echo "Using Dockerfile: ${DOCKERFILE_PATH}"
                    echo "Build context: ${WORKSPACE}"
                    
                    # Ensure we're in the workspace root for build context
                    cd "${WORKSPACE}"
                    
                    # Build the Docker image
                    docker build -t \$IMAGE_TAG \\
                        --build-arg APP_VERSION=\$APP_VERSION \\
                        -f "${DOCKERFILE_PATH}" \\
                        . || {
                        echo "‚ùå Docker build failed!"
                        echo "Dockerfile content:"
                        cat "${DOCKERFILE_PATH}"
                        echo "Build context files:"
                        ls -la
                        exit 1
                    }
                    
                    echo "‚úÖ Docker image built successfully: \$IMAGE_TAG"
                    docker images | grep \$IMAGE_TAG || echo "Warning: Image not found in docker images output"
                """
            }
        }

        stage('üöÄ Run App Container') {
            steps {
                sh """
                    APP_VERSION=${params.APP_VERSION}
                    CONTAINER_NAME=chaos-app-v\$APP_VERSION
                    IMAGE_TAG=ci-cd-chaos-app:v\$APP_VERSION
                    echo "üöÄ Running app container: \$CONTAINER_NAME on port 3000..."
                    docker run -d --name \$CONTAINER_NAME \\
                        -p 3000:3000 \\
                        \$IMAGE_TAG
                """
            }
        }

        stage('üìã Check App Logs') {
            steps {
                sh """
                    APP_VERSION=${params.APP_VERSION}
                    CONTAINER_NAME=chaos-app-v\$APP_VERSION
                    echo "‚è≥ Waiting for app to start..."
                    sleep 5
                    echo "=== Container Logs ==="
                    docker logs \$CONTAINER_NAME
                """
            }
        }

        stage('üåê Test App HTTP Response') {
            steps {
                sh """
                    APP_VERSION=${params.APP_VERSION}
                    CONTAINER_NAME=chaos-app-v\$APP_VERSION
                    echo "üåê Testing HTTP response from app..."
                    sleep 3
                    # Test from inside the container network
                    STATUS_CODE=\$(docker exec \$CONTAINER_NAME curl -s -o /dev/null -w '%{http_code}' http://localhost:3000 || echo "000")
                    echo "HTTP Status: \$STATUS_CODE"
                    if [ "\$STATUS_CODE" -ne 200 ]; then
                        echo "‚ùå App did not respond correctly!"
                        echo "Container logs:"
                        docker logs \$CONTAINER_NAME
                        echo "Container status:"
                        docker ps | grep \$CONTAINER_NAME
                        exit 1
                    else
                        echo "‚úÖ App responded successfully!"
                    fi
                """
            }
        }

        stage('üéâ Demo Instructions') {
            steps {
                echo "\n\nüéâ DEMO READY!"
                echo "App version: ${params.APP_VERSION} is running in Docker container: $CONTAINER_NAME"
                echo "Access it at: http://localhost:3000"
                echo "To view logs: docker logs $CONTAINER_NAME"
                echo "To stop/remove: docker rm -f $CONTAINER_NAME"
                echo "Switch versions by re-running pipeline with a different APP_VERSION."
                echo "---"
            }
        }
    }

    post {
        always {
            script {
                if (params.CLEANUP_AFTER) {
                    echo "üßπ CLEANUP_AFTER is true: Removing container $CONTAINER_NAME..."
                    sh """
                        docker rm -f $CONTAINER_NAME || true
                        echo '‚úÖ Cleanup completed'
                    """
                } else {
                    echo "üõë Container $CONTAINER_NAME left running for demo/manual inspection."
                }
                echo "‚ú® Chaos Agent defeated‚Ä¶ for now! Pipeline finished."
            }
        }
        success {
            echo "üéâ Docker build and deployment completed successfully!"
        }
        failure {
            echo "üí• Docker build or deployment failed - Chaos Agent strikes again!"
        }
    }
}
